
## PuzzleBID语义编程

用于检查游戏业务逻辑和精简合并一些函数

```

1、注册

更新玩家：玩家唯一ID、钱包地址、推荐人、注册时间

更新玩家：唯一ID库、钱包地址库

更新玩家：最后一次购买时间、首发购买碎片数小计、首发购买总计金额、二次购买总计金额

2、查询玩家要购买的碎片的最后交易价格（用于计算是否溢价）

3、更新碎片：最新交易价格、归属玩家

4、更新玩家：最后一次购买时间

5、更新平台：总交易金额

6、游戏开始

if(碎片是第二次被玩家购买吗？) {

    二次购买业务函数()

} else {

    更新碎片：被购买次数

    首发购买业务函数()

}

7、游戏结束

if(当前玩家把碎片收集齐全了吗？) {

    更新作品的结束时间

    结束游戏前瓜分奖池算法函数()

    处理成我的藏品函数()
}

---

#### 业务子函数：

function 首发购买业务函数() {

    更新碎片：首发购买者玩家唯一ID、钱包地址

    更新玩家：首发购买碎片数小计、首发购买总计金额

    艺术家分到ETH

    平台薅羊毛ETH

    更新作品奖池、平台代为保管这些ETH 

}

function 二次购买业务函数() {

    //更新碎片：归属

    if(玩家是再次来玩当前这个作品吗？) {

        更新到二次购买名单中

    }

    更新玩家：二次购买总计金额

    查询一下碎片实时价格

    if(有涨价（溢价）吗？) {

        查询分红比例

        艺术家分到ETH 溢价的10%

        平台薅羊毛ETH 实时价的2%

        更新作品奖池、平台代为保管这些ETH 溢价的10%

        剩余的给上一玩家

    } else {

        降价后的实时价格ETH 给上一玩家

    }   

}

function 结束游戏前瓜分奖池算法函数() {

    查询最后的分红比例

    平台薅羊毛ETH

    当前作品的首发玩家分红函数()

    当前作品的二次玩家分红函数()

}

funcion 当前作品的首发玩家分红函数() {

    查询首发玩家名单列表

    for(i=0; i<首发玩家名单数-1; i++) {

        首发玩家，发放分红ETH，从平台合约转账，奖池未扣除数量

    }

}

funcion 当前作品的首发玩家分红函数() {

    查询二次玩家名单列表

    for(i=0; i<二次玩家名单数-1; i++) {

        二次玩家，发放分红ETH，从平台合约转账，奖池未扣除数量

    }

}

```